# C++ Module 01 #

Выделение памяти, указатели на элементы, ссылки, оператор switch

Резюме:

Этот документ содержит упражнения модуля 01 из модулей C++.

Версия: `9`

## Содержание ##

1. [Введение](#Введение)
2. [Общие инструкции](#Общие-инструкции)
3. [Упражнение 00: BraiiiiiiinnnzzzZ](#Упражнение-00-BraiiiiiiinnnzzzZ)
4. [Упражнение 01: Moar brainz!](#Упражнение-01-Moar-brainz!)
5. [Упражнение 02: HI THIS IS BRAIN](#Упражнение-02-HI-THIS-IS-BRAIN)

## Глава I ##

### Введение ###

C++ — это язык программирования общего назначения, созданный Бьерном Страуструпом как расширение языка программирования C или «C with Classes» (источник: Википедия).

Цель этих модулей — познакомить вас с объектно-ориентированным программированием. Это будет отправной точкой вашего путешествия по C++.

Многие языки рекомендуются для изучения ООП. Мы решили выбрать C++, так как он является производным от вашего старого знакомого C. Поскольку это сложный язык, и для простоты ваш код будет соответствовать стандарту C++98.

Мы знаем, что современный C++ сильно отличается во многих аспектах. Так что, если вы хотите стать опытным разработчиком C++, вам решать, идти ли дальше после 42 Common Core!

## Глава II ##

### Общие инструкции ###

#### Компиляция ####
* Скомпилируйте свой код с помощью C++ и флагов -Wall -Wextra -Werror
* Ваш код все равно должен компилироваться, если вы добавите флаг -std=c++98
#### Форматирование и соглашения об именах ####
* Каталоги упражнений будут называться следующим образом: ex00, ex01, ..., ex[n]
* Назовите ваши файлы, классы, функции, функции-члены и атрибуты, как это требуется в рекомендациях.
* Пишите имена классов в формате UpperCamelCase. Файлы, содержащие код класса, всегда будут называться в соответствии с именем класса.

	Например:
	ClassName.hpp/ClassName.h, ClassName.cpp или ClassName.tpp. Затем, если у вас есть заголовочный файл, содержащий определение класса «BrickWall», обозначающего кирпичную стену, его имя будет BrickWall.hpp.
* Если не указано иное, каждое выходное сообщение должно заканчиваться символом новой строки и выводиться на стандартный вывод.
* До свидания, Норминетт! В модулях C++ не применяется стиль кодирования. Вы можете следить за своим любимым. Но имейте в виду, что код, который не могут понять ваши коллеги-оценщики, — это код, который они не могут оценить. Старайтесь писать чистый и читаемый код.

#### Разрешено/Запрещено ####

Вы больше не кодируете на C. Время С++! Поэтому:

* Вам разрешено использовать почти все из стандартной библиотеки. Таким образом, вместо того, чтобы придерживаться того, что вы уже знаете, было бы разумно использовать как можно больше C++-версий функций C, к которым вы привыкли.
* Однако вы не можете использовать никакую другую внешнюю библиотеку. Это означает, что C++11 (и производные формы) и библиотеки Boost запрещены. Также запрещены следующие функции: *printf(), *alloc() и free(). Если вы их используете, ваша оценка будет 0 и все.
* Обратите внимание, что если явно не указано иное, использование пространства имен `<ns_name>` и `friend` ключевых слов запрещено. В противном случае ваша оценка будет -42.
* Вам разрешено использовать STL только в Модуле 08. Это означает: никаких контейнеров (vector/list/map и т. д.) и никаких алгоритмов (все, что требует включения заголовка <algorithm>) до этого момента. В противном случае ваша оценка будет -42.

#### Несколько требований к дизайну ####
* Утечка памяти происходит и в C++. Когда вы выделяете память (используя ключевое слово new), вы должны избегать утечек памяти.
* Начиная с Модуля 02 и заканчивая Модулем 08, ваши классы должны быть разработаны в `Orthodox Canonical Form`, за исключением случаев, когда прямо указано иное.
* Любая реализация функции, помещенная в заголовочный файл (кроме шаблонов функций), означает 0 для упражнения.
* Вы должны иметь возможность использовать каждый из ваших заголовков независимо от других. Таким образом, они должны включать все необходимые им зависимости. Однако вы должны избежать проблемы двойного включения, добавив защиту включения. В противном случае ваша оценка будет 0.

#### Прочти меня ####
* При необходимости вы можете добавить несколько дополнительных файлов (например, для разделения кода). Поскольку эти назначения не проверяются программой, не стесняйтесь делать это при условии, что вы сдадите обязательные файлы.
* Иногда рекомендации упражнения кажутся короткими, но в примерах могут быть показаны требования, которые явно не прописаны в инструкциях.
* Полностью прочитайте каждый модуль перед началом! Действительно, сделай это.
* Во имя Одина, во имя Тора! Включи мозг!!!

	> Вам придется реализовать много классов. Это может показаться утомительным, если только вы не умеете писать сценарии в своем любимом текстовом редакторе.

	> Вам предоставляется определенная свобода для выполнения упражнений. Тем не менее, соблюдайте обязательные правила и не ленитесь. Вы упустите много полезной информации! Не стесняйтесь читать о теоретических концепциях.

## Глава III ##

### Упражнение 00: BraiiiiiiinnnzzzZ ###


Название программы  | BraiiiiiiinnnzzzZ
:------------------:|:---------------
Каталог сдачи		| ex00/
Файлы для сдачи		| Makefile, main.cpp, Zombie.{h, hpp}, Zombie.cpp, newZombie.cpp, randomChump.cpp
Запрещенные функции	| Нет

Во-первых, реализуйте класс `Zombie`. Он имеет строковое имя частного атрибута.
Добавьте функцию-член void объявлять (void); к классу Зомби. Зомби объявляют себя следующим образом:

    <name>: BraiiiiiiinnnzzzZ...

Не печатайте угловые скобки (< и >). Для `Zombie` по имени `Foo` сообщение будет таким:

    Foo: BraiiiiiiinnnzzzZ...

Затем реализуйте две следующие функции:

* `Zombie* newZombie( std::string name );` Он создает зомби, дает ему имя и возвращает его, чтобы вы могли использовать его за пределами области действия функции.

* `void randomChump( std::string name );` Он создает зомби, назовите его, и зомби объявит о себе.

Теперь, в чем суть упражнения? Вы должны определить, в каком случае лучше разместить зомби в стеке или в куче.

Зомби должны быть уничтожены, когда они вам больше не нужны. Деструктор должен вывести сообщение с именем зомби в целях отладки.

## Глава IV ##

### Упражнение 01: Moar brainz! ###

Название программы  | BraiiiiiiinnnzzzZ
:------------------:|:---------------
Каталог сдачи		| ex01/
Файлы для сдачи		| Makefile, main.cpp, Zombie.{h, hpp}, Zombie.cpp, zombieHorde.cpp
Запрещенные функции	| Нет

Время создать орду зомби!

Реализуйте следующую функцию в соответствующем файле:

Zombie* zombieHorde( int N, std::string name );

Он должен выделить N объектов-зомби за один раз. Затем он должен инициализировать зомби, дав каждому из них имя, переданное в качестве параметра. Функция возвращает указатель на первого зомби.

Реализуйте свои собственные тесты, чтобы убедиться, что ваша функция zombieHorde() работает должным образом.
Попытайтесь вызвать анонс() для каждого из зомби.

Не забудьте удалить всех зомби и проверить наличие утечек памяти

## Глава V ##

### Упражнение 02: HI THIS IS BRAIN ###

Название программы  | HI THIS IS BRAIN
:------------------:|:---------------
Каталог сдачи		| ex02/
Файлы для сдачи		| Makefile, main.cpp
Запрещенные функции	| Нет

Напишите программу, которая содержит:
* Строковая переменная, инициализированная как "HI THIS IS BRAIN".
* stringPTR: указатель на строку.
* stringREF: ссылка на строку.
Ваша программа должна напечатать:
* Адрес памяти строковой переменной.
* Адрес памяти, удерживаемый stringPTR
* Адрес памяти, удерживаемый stringREF.
А потом:
* Значение строковой переменной.
* Значение, на которое указывает stringPTR.
* Значение, на которое указывает stringREF.

Вот и все, никаких хитростей. Цель этого упражнения — демистифицировать ссылки, которые могут показаться совершенно новыми. Хотя есть небольшие отличия, это еще один синтаксис для того, что вы уже делаете: манипулирование адресами.

## Глава VI ##

### Упражнение 03: Unnecessary violence ###

Название программы  | Unnecessary violence
:------------------:|:---------------
Каталог сдачи		| ex03/
Файлы для сдачи		| Makefile, main.cpp, Weapon.{h, hpp}, Weapon.cpp, HumanA.{h, hpp}, HumanA.cpp, HumanB.{h, hpp}, HumanB.cpp
Запрещенные функции	| Нет

Реализуйте класс оружия, который имеет:
* Частный тип атрибута, представляющий собой строку.
* Функция-член `getType()`, которая возвращает константную ссылку на тип.
* Функция-член `setType()`, которая устанавливает тип, используя новый, переданный в качестве параметра.

Теперь создайте два класса: `HumanA` и `HumanB`. У них обоих есть оружие и имя. У них также есть функция `Attack()`, которая отображает (конечно, без угловых скобок):

    <name> attacks with their <weapon type>

`HumanA` и `HumanB` почти одинаковы, за исключением этих двух крошечных деталей:

* В то время как `HumanA` принимает оружие в своем конструкторе, `HumanB` — нет.
* `HumanB` не всегда может иметь оружие, тогда как `HumanA` всегда будет вооружен.

Если ваша реализация верна, выполнение следующего кода напечатает атаку "crude spiked club", а затем вторую атаку "some other type of club" для обоих тестовых случаев:

    int main()
    {
        {
            Weapon club = Weapon("crude spiked club");
            HumanA bob("Bob", club);
            bob.attack();
            club.setType("some other type of club");
            bob.attack();
        }
        {
        Weapon club = Weapon("crude spiked club");
        HumanB jim("Jim");
        jim.setWeapon(club);
        jim.attack();
        club.setType("some other type of club");
        jim.attack();
        }
        return 0;
    }

Не забудьте проверить наличие утечек памяти.

    Как вы думаете, в каком случае было бы лучше использовать указатель на Оружие? А отсылка к оружию? Почему? Подумайте об этом, прежде чем приступить к этому упражнению.

## Глава VII ##

### Упражнение 04:  Sed is for losers ###

Название программы  |  Sed is for losers
:------------------:|:---------------
Каталог сдачи		| ex04/
Файлы для сдачи		| Makefile, main.cpp, *.cpp, *.{h, hpp}
Запрещенные функции	| Нет

Создайте программу, которая принимает три параметра в следующем порядке: имя файла и две строки, s1 и s2.

Он откроет файл <filename> и скопирует его содержимое в новый файл <filename>.replace, заменив каждое вхождение s1 на s2.

Использование функций манипулирования файлами C запрещено и будет считаться мошенничеством. Разрешены все функции-члены класса std::string, кроме replace. Используйте их с умом!

Конечно, обрабатывать неожиданные входные данные и ошибки. Вы должны создать и сдать свои собственные тесты, чтобы убедиться, что ваша программа работает должным образом.

## Глава VIII ##

### Упражнение 05: Harl 2.0 ###

Название программы  |  Harl 2.0
:------------------:|:---------------
Каталог сдачи		| ex05/
Файлы для сдачи		| Makefile, main.cpp, Harl.{h, hpp}, Harl.cpp
Запрещенные функции	| Нет

Ты знаешь Харла? Мы все делаем, не так ли? Если вы этого не сделаете, найдите ниже комментарии, которые делает Харл. Они классифицируются по уровням:

* Уровень «DEBUG»: сообщения отладки содержат контекстную информацию. В основном они используются для диагностики проблем. Пример: "I love having extra bacon for my 7XL-double-cheese-triple-pickle-specialketchup burger. I really do!"
* Уровень «INFO»: Эти сообщения содержат обширную информацию. Они полезны для отслеживания выполнения программы в производственной среде. Пример: "I cannot believe adding extra bacon costs more money. You didn’t put enough bacon in my burger! If you did, I wouldn’t be asking for more!"
* Уровень "WARNING". Предупреждающие сообщения указывают на возможную проблему в системе. Однако с этим можно справиться или проигнорировать.
Пример: «Я думаю, что заслуживаю того, чтобы получить немного бекона бесплатно. Я прихожу сюда уже много лет, а вы начали работать здесь с прошлого месяца».
* "ERROR" level: Эти сообщения указывают на то, что произошла неисправимая ошибка. Обычно это критическая проблема, требующая ручного вмешательства. 
Example: "This is unacceptable! I want to speak to the manager now."

Ты будешь автоматизировать Харла. Это будет несложно, так как он всегда говорит одно и то же. Вам необходимо создать класс Harl со следующими закрытыми функциями-членами:

* void debug( void );
* void info( void );
* void warning( void );
* void error( void );

У Harl также есть общедоступная функция-член, которая вызывает четыре указанные выше функции-члена в зависимости от уровня, переданного в качестве параметра:

* void complain( std::string level );

Цель этого упражнения — использовать указатели на функции-члены. Это не предложение. Харлу приходится жаловаться, не используя лес if/else if/else. Он не думает дважды!

Создайте и сдайте тесты, чтобы показать, что Харл много жалуется. Вы можете использовать примеры комментариев.

## Глава IX ##

### Упражнение 06: Harl filter ###

Название программы  |  Harl filter
:------------------:|:---------------
Каталог сдачи		| ex06/
Файлы для сдачи		| Makefile, main.cpp, Harl.{h, hpp}, Harl.cpp
Запрещенные функции	| Нет

Иногда не хочется обращать внимание на все, что говорит Харл. Внедрите систему для фильтрации того, что говорит Харл, в зависимости от уровней журнала, которые вы хотите прослушать.

Создайте программу, которая принимает в качестве параметра один из четырех уровней. Он будет отображать все сообщения с этого уровня и выше. Например:

    $> ./harlFilter "WARNING"
    [ WARNING ]
    I think I deserve to have some extra bacon for free.
    I've been coming for years whereas you started working here since last month.
    [ ERROR ]
    This is unacceptable, I want to speak to the manager now.
    $> ./harlFilter "I am not sure how tired I am today..."
    [ Probably complaining about insignificant problems ]

Хотя есть несколько способов справиться с Харлом, один из самых эффективных — ВЫКЛЮЧИТЬ его.

Дайте имя harlFilter вашему исполняемому файлу.

> Вы можете пройти этот модуль, не выполняя упражнение 06.

