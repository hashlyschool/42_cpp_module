# C++ Module 02 #

Специальный полиморфизм, перегрузка операторов и ортодоксальная каноническая форма класса

Резюме:

Этот документ содержит упражнения модуля 02 из модулей C++.

Версия: `7`

## Содержание ##

1.	[Введение](#Введение)
2.	[Общие инструкции](#Общие-инструкции)
3.	[Новые правила](#Новые-правила)
4.	[Упражнение 00: My First Class in Orthodox Canonical Form](#Упражнение-00-My-First-Class-in-Orthodox-Canonical-Form)
5.	[Упражнение 01: Towards a more useful fixed-point number class](#Упражнение-01-Towards-a-more-useful-fixed-point-number-class)
6.	[Упражнение 02: Now we are talking](#Упражнение-02-Now-we-are-talking)
7.	[Упражнение 03: BSP](#Упражнение-03-BSP)

## Глава I ##

### Введение ###

C++ — это язык программирования общего назначения, созданный Бьерном Страуструпом как расширение языка программирования C или «C with Classes» (источник: Википедия).

Цель этих модулей — познакомить вас с объектно-ориентированным программированием. Это будет отправной точкой вашего путешествия по C++.

Многие языки рекомендуются для изучения ООП. Мы решили выбрать C++, так как он является производным от вашего старого знакомого C. Поскольку это сложный язык, и для простоты ваш код будет соответствовать стандарту C++98.

Мы знаем, что современный C++ сильно отличается во многих аспектах. Так что, если вы хотите стать опытным разработчиком C++, вам решать, идти ли дальше после 42 Common Core!

## Глава II ##

### Общие инструкции ###

#### Компиляция ####
* Скомпилируйте свой код с помощью C++ и флагов -Wall -Wextra -Werror
* Ваш код все равно должен компилироваться, если вы добавите флаг -std=c++98
#### Форматирование и соглашения об именах ####
* Каталоги упражнений будут называться следующим образом: ex00, ex01, ..., ex[n]
* Назовите ваши файлы, классы, функции, функции-члены и атрибуты, как это требуется в рекомендациях.
* Пишите имена классов в формате UpperCamelCase. Файлы, содержащие код класса, всегда будут называться в соответствии с именем класса.

	Например:
	ClassName.hpp/ClassName.h, ClassName.cpp или ClassName.tpp. Затем, если у вас есть заголовочный файл, содержащий определение класса «BrickWall», обозначающего кирпичную стену, его имя будет BrickWall.hpp.
* Если не указано иное, каждое выходное сообщение должно заканчиваться символом новой строки и выводиться на стандартный вывод.
* До свидания, Норминетт! В модулях C++ не применяется стиль кодирования. Вы можете следить за своим любимым. Но имейте в виду, что код, который не могут понять ваши коллеги-оценщики, — это код, который они не могут оценить. Старайтесь писать чистый и читаемый код.

#### Разрешено/Запрещено ####

Вы больше не кодируете на C. Время С++! Поэтому:

* Вам разрешено использовать почти все из стандартной библиотеки. Таким образом, вместо того, чтобы придерживаться того, что вы уже знаете, было бы разумно использовать как можно больше C++-версий функций C, к которым вы привыкли.
* Однако вы не можете использовать никакую другую внешнюю библиотеку. Это означает, что C++11 (и производные формы) и библиотеки Boost запрещены. Также запрещены следующие функции: *printf(), *alloc() и free(). Если вы их используете, ваша оценка будет 0 и все.
* Обратите внимание, что если явно не указано иное, использование пространства имен `<ns_name>` и `friend` ключевых слов запрещено. В противном случае ваша оценка будет -42.
* Вам разрешено использовать STL только в Модуле 08. Это означает: никаких контейнеров (vector/list/map и т. д.) и никаких алгоритмов (все, что требует включения заголовка <algorithm>) до этого момента. В противном случае ваша оценка будет -42.

#### Несколько требований к дизайну ####
* Утечка памяти происходит и в C++. Когда вы выделяете память (используя ключевое слово new), вы должны избегать утечек памяти.
* Начиная с Модуля 02 и заканчивая Модулем 08, ваши классы должны быть разработаны в `Orthodox Canonical Form`, за исключением случаев, когда прямо указано иное.
* Любая реализация функции, помещенная в заголовочный файл (кроме шаблонов функций), означает 0 для упражнения.
* Вы должны иметь возможность использовать каждый из ваших заголовков независимо от других. Таким образом, они должны включать все необходимые им зависимости. Однако вы должны избежать проблемы двойного включения, добавив защиту включения. В противном случае ваша оценка будет 0.

#### Прочти меня ####
* При необходимости вы можете добавить несколько дополнительных файлов (например, для разделения кода). Поскольку эти назначения не проверяются программой, не стесняйтесь делать это при условии, что вы сдадите обязательные файлы.
* Иногда рекомендации упражнения кажутся короткими, но в примерах могут быть показаны требования, которые явно не прописаны в инструкциях.
* Полностью прочитайте каждый модуль перед началом! Действительно, сделай это.
* Во имя Одина, во имя Тора! Включи мозг!!!

	> Вам придется реализовать много классов. Это может показаться утомительным, если только вы не умеете писать сценарии в своем любимом текстовом редакторе.

	> Вам предоставляется определенная свобода для выполнения упражнений. Тем не менее, соблюдайте обязательные правила и не ленитесь. Вы упустите много полезной информации! Не стесняйтесь читать о теоретических концепциях.

## Глава III ##

### Новые правила ###

Отныне все ваши занятия должны быть оформлены в православной канонической форме, если прямо не указано иное. Затем они будут реализовывать четыре обязательные функции-члены ниже:
* Конструктор по умолчанию
* Конструктор копирования
* Копировать оператор присваивания
* Деструктор


## Глава IV ##

### Упражнение 00: My First Class in Orthodox Canonical Form ###

Название программы  | My First Class in Orthodox Canonical Form
:------------------:|:---------------
Каталог сдачи		| ex00/
Файлы для сдачи		| Makefile, main.cpp, Fixed.{h, hpp}, Fixed.cpp
Запрещенные функции	| Нет

Вы думаете, что знаете целые числа и числа с плавающей запятой. Как мило.

Пожалуйста, прочтите эту 3-страничную статью ([1](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point.html), [2](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html), [3](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_printing.html)), чтобы убедиться, что вы этого не делаете. Давай, прочитай это.

До сегодняшнего дня каждое число, которое вы использовали в своем коде, было либо целым числом, либо числом с плавающей запятой, либо любым из их вариантов (short, char, long, double и т. д.). Прочитав статью выше, можно с уверенностью предположить, что целые числа и числа с плавающей запятой имеют противоположные характеристики.

Но сегодня все изменится. Вы откроете для себя новый удивительный тип чисел: числа с фиксированной точкой! Навсегда отсутствующие в скалярных типах большинства языков, числа с фиксированной запятой предлагают ценный баланс между производительностью, точностью, диапазоном и точностью. Это объясняет, почему числа с фиксированной точкой особенно применимы к компьютерной графике, обработке звука или научному программированию, и это лишь некоторые из них.

Поскольку в C++ отсутствуют числа с фиксированной точкой, вы собираетесь их добавить. [Эта статья](https://inst.eecs.berkeley.edu//~cs61c/sp06/handout/fixedpt.html) из Беркли — хорошее начало. Если вы не знаете, что такое Университет Беркли, прочитайте [этот раздел](https://en.wikipedia.org/wiki/University_of_California,_Berkeley#Notable_alumni.2C_faculty.2C_and_staff) его страницы в Википедии.

Создайте класс в ортодоксальной канонической форме, который представляет число с фиксированной точкой:

* Частные члены:
	* Целое число для хранения значения числа с фиксированной точкой.
	* Статическое постоянное целое число для хранения количества дробных битов. Его значением всегда будет целочисленный литерал 8.
* Общественные члены:
	* Конструктор по умолчанию, который инициализирует числовое значение с фиксированной точкой равным 0.
	* Конструктор копирования.
	* Перегрузка оператора присваивания копии.
	* Деструктор.
	* Функция-член `int getRawBits(void) const;` который возвращает необработанное значение значения с фиксированной точкой.
	* Функция-член `void setRawBits(int const raw);` который устанавливает необработанное значение числа с фиксированной точкой.

Running this code:

	#include <iostream>

	int main( void ) {
		Fixed a;
		Fixed b( a );
		Fixed c;
		c = b;
		std::cout << a.getRawBits() << std::endl;
		std::cout << b.getRawBits() << std::endl;
		std::cout << c.getRawBits() << std::endl;
		return 0;
	}

Should output something similar to:

	$> ./a.out
	Default constructor called
	Copy constructor called
	Copy assignment operator called // <-- This line may be missing depending on your implementation
	getRawBits member function called
	Default constructor called
	Copy assignment operator called
	getRawBits member function called
	getRawBits member function called
	0
	getRawBits member function called
	0
	getRawBits member function called
	0
	Destructor called
	Destructor called
	Destructor called
	$>



## Глава V ##

### Упражнение 01: Towards a more useful fixed-point number class ###

Название программы  | Towards a more useful fixed-point number class
:------------------:|:---------------
Каталог сдачи		| ex01/
Файлы для сдачи		| Makefile, main.cpp, Fixed.{h, hpp}, Fixed.cpp
Запрещенные функции	| roundf (from <cmath>)

Предыдущее упражнение было хорошим началом, но наш класс довольно бесполезен. Он может представлять только значение 0.0.

Добавьте в класс следующие общедоступные конструкторы и общедоступные функции-члены:

* Конструктор, который принимает постоянное целое число в качестве параметра. Он преобразует его в соответствующее значение фиксированной точки. Дробное значение битов инициализируется равным 8, как в упражнении 00.
* Конструктор, принимающий в качестве параметра постоянное число с плавающей запятой. Он преобразует его в соответствующее значение фиксированной точки. Дробное значение битов инициализируется равным 8, как в упражнении 00.
* Функция-член `float toFloat(void) const`, которая преобразует значение с фиксированной запятой в значение с плавающей запятой.
* Функция-член `int toInt(void) const;`, которая преобразует значение с фиксированной запятой в целочисленное значение.

И добавьте следующую функцию в файлы класса `Fixed`:

* Перегрузка оператора вставки (`«`), который вставляет представление числа с фиксированной запятой с плавающей запятой в объект выходного потока, переданный в качестве параметра.

Running this code:

	#include <iostream>

	int main( void ) {
		Fixed a;
		Fixed const b( 10 );
		Fixed const c( 42.42f );
		Fixed const d( b );
		a = Fixed( 1234.4321f );
		std::cout << "a is " << a << std::endl;
		std::cout << "b is " << b << std::endl;
		std::cout << "c is " << c << std::endl;
		std::cout << "d is " << d << std::endl;
		std::cout << "a is " << a.toInt() << " as integer" << std::endl;
		std::cout << "b is " << b.toInt() << " as integer" << std::endl;
		std::cout << "c is " << c.toInt() << " as integer" << std::endl;
		std::cout << "d is " << d.toInt() << " as integer" << std::endl;
	return 0;
}

Should output something similar to:

	$> ./a.out
	Default constructor called
	Int constructor called
	Float constructor called
	Copy constructor called
	Copy assignment operator called
	Float constructor called
	Copy assignment operator called
	Destructor called
	a is 1234.43
	b is 10
	c is 42.4219
	d is 10
	a is 1234 as integer
	b is 10 as integer
	c is 42 as integer
	d is 10 as integer
	Destructor called
	Destructor called
	Destructor called
	Destructor called
	$>

## Глава VI ##

### Упражнение 02: Now we’re talking ###

Название программы  | Now we’re talking
:------------------:|:---------------
Каталог сдачи		| ex02/
Файлы для сдачи		| Makefile, main.cpp, Fixed.{h, hpp}, Fixed.cpp
Запрещенные функции	| roundf (from <cmath>)

Добавьте общедоступные функции-члены в свой класс, чтобы перегрузить следующие операторы:

* 6 операторов сравнения: `>`, `<`, `>=`, `<=`, `==` и `!=`.
* 4 арифметических оператора: `+`, `-`, `*` и `/`.
* 4 оператора инкремента/декремента (преинкремент и постинкремент, предекремент и постдекремент), которые будут увеличивать или уменьшать значение фиксированной точки от наименьшего представимого значения, такого как 1 + error > 1.


Добавьте эти четыре открытые перегруженные функции-члены в свой класс:

* Статическая функция-член `min`, которая принимает в качестве параметров две ссылки на числа с фиксированной точкой и возвращает ссылку на наименьшую из них.
* Статическая функция-член `min`, которая принимает в качестве параметров две ссылки на постоянные числа с фиксированной точкой и возвращает ссылку на наименьшее из них.
* Статическая функция-член `max`, которая принимает в качестве параметров две ссылки на числа с фиксированной точкой и возвращает ссылку на наибольшую из них.
* Статическая функция-член `max`, которая принимает в качестве параметров две ссылки на постоянные числа с фиксированной точкой и возвращает ссылку на наибольшее из них.

Вы должны проверить каждую функцию вашего класса. Однако, запустив код ниже:

	#include <iostream>

	int main( void ) {
		Fixed a;
		Fixed const b( Fixed( 5.05f ) * Fixed( 2 ) );
		std::cout << a << std::endl;
		std::cout << ++a << std::endl;
		std::cout << a << std::endl;
		std::cout << a++ << std::endl;
		std::cout << a << std::endl;
		std::cout << b << std::endl;
		std::cout << Fixed::max( a, b ) << std::endl;
		return 0;
	}

Должно выводить что-то вроде (для большей читабельности сообщения конструктора/деструктора удалены в примере ниже):

	$> ./a.out
	0
	0.00390625
	0.00390625
	0.00390625
	0.0078125
	10.1016
	10.1016
	$>

## Глава VII ##

### Упражнение 03: BSP ###

Название программы  | BSP
:------------------:|:---------------
Каталог сдачи		| ex03/
Файлы для сдачи		| Makefile, main.cpp, Fixed.{h, hpp}, Fixed.cpp, Point.{h, hpp}, Point.cpp, bsp.cpp
Запрещенные функции	| roundf (from <cmath>)

Теперь, когда у вас есть функциональный класс `Fixed`, было бы неплохо использовать его.

Реализуйте функцию, которая указывает, находится ли точка внутри треугольника или нет. Очень полезно, не так ли?

BSP расшифровывается как бинарное разделение пространства. Добро пожаловать. :)

	Вы можете пройти этот модуль, не выполняя упражнение 03

Давайте начнем с создания `class Point` в `Orthodox Canonical Form`, который представляет 2D-точку:

* Private members:
	* Атрибут `Fixed const x`.
	* Атрибут `Fixed const y`.
	* Еще что-нибудь полезное.

* Public members:
	* A default `constructor` that initializes `x` and `y` to 0.
	* A constructor that takes as parameters two constant floating-point numbers. It initializes x and y with those parameters.
	* A copy constructor.
	* A copy assignment operator overload.
	* A destructor.
	* Anything else useful.

В заключение реализуйте следующую функцию в соответствующем файле:

	`bool bsp( Point const a, Point const b, Point const c, Point const point);`

* a, b, c: Вершины треугольника.
* point: точка для проверки.
* return:
	* `True`, если точка находится внутри треугольника.
	* `False` в противном случае. Таким образом, если точка является вершиной или ребром, она вернет False.

Реализуйте и сдайте свои собственные тесты, чтобы убедиться, что ваш класс ведет себя так, как ожидалось.
